# 변수의 유효범외와 클로저

자바스크립트는 함수 지향 언어입니다. 이런 특징은 개발자에게 많은 자유를 줍니다. 함수를 동적으로 생성할 수 있고, 생성한 함수를 다른 함수에 인수로 넘길 수 있으며, 생성된 곳이 아닌 곳에서 함수를 호출할 수도 있기 때문입니다.   
   
함수 내부에서 함수 외부에 있는 변수에 접근할 수 있다는 사실은 앞서 학습해서 알고 계실 겁니다.   
   
그런데 함수가 생성된 이후에 외부 변수가 변경되면 어떤 일이 발생할까요? 함수는 새로운 값을 가져올까요? 함수는 호출 되는 곳을 기준으로 외부 변수에 접근할까요?   
   
이젠 이런 간단한 시나리오부터 시작해 좀 더 복잡한 시나리오를 다룰 수 있도록 지식을 확장해 봅시다.   
   
❕ 여기선 `let`, `const`로 선언한 변수만 다룹니다.   
자바스크립트에서는 3개의 키워드를 사용해 변수를 선언할 수 있습니다. 모던한 방식인 `let`, `const`가 있고, 과거의 잔재인 `var`도 있습니다.
- 이번 주제의 모든 예시에선 `let`으로 선언한 변수를 사용할 예정입니다.
- `const`로 선언한 변수 역시 `let`변수와 동일하게 동작합니다. 따라서 예시의 `let`을 `const`로 바꿔도 동일한 동작을 기대할 수 있습니다.
- `var`는 `let`과 `const`로 선언한 변수와 몇 가지 중요한 차이가 있습니다.
   


## 코드 블록

코드 블록 `{...}` 안에서 선언한 변수는 블록 안에서만 사용할 수 있습니다.
```
{
  let message = "안녕하세요.";
  alert(message);  // 안녕하세요.
}

alert(message);  // ReferenceError...
```
이런 블록의 특징은 특정 작업을 수행하는 코드를 묶어두는 용도로 활용할 수 있습니다. 블록 안엔 작업 수행에만 필요한 변수가 들어갑니다.
```
{
  let message = "안녕하세요.";
  alert(message);  // 안녕하세요.
}
{
  let message = "안녕히 가세요.";
  alert(message);  // 안녕히 가세요.
}
```
❕블록이 없으면 에러가 발생합니다.   
이미 선언된 변수와 동일한 이름을 가진 변수를 별도의 블록 없이 `let`으로 선언하면 에러가 발생합니다.
```
// 메시지 출력
let message = "안녕하세요.";
alert(message);

// 또 다른 메시지 출력
let message = "안녕히 가세요.";  // SyntaxError...
alert(message);
```
`if`, `for`, `while`등에서도 마찬가지로 `{...}`안에서 선언한 변수는 오직 블록 안에서만 접근 가능합니다.
```
if (true) {
  let phrase = "안녕하세요!";
  alert(phrase);  // 안녕하세요!
}

alert(phrase);  // ReferenceError...
```
`if`블록 밖에 있는 `alert`는 `phrase`에 접근 할 수 없기 때문에 위 예시를 실행하면 에러가 발생합니다.   
   
이런 특징은 변수의 유효 범위를 블록 범위, 특히 `if` 분기문 범위로 한정시킬 수 있어서 아주 유용합니다.   
   
`if`뿐만 아니라 `for`, `while`반복문에서도 동일한 특징이 적용됩니다.
```
for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2가 출력
}

alert(i);  // ReferenceError...
```
참고로 `for`문에서 `for`옆 괄호 안에서 선언한 변수는 `{...}`밖에 있긴 하지만 블록 `{...}`에 속하는 코드로 취급됩니다.



## 중첩 함수

함수 내부에서 선언한 함수는 '중첩'함수라고 부릅니다.   
   
자바스크립트에선 손쉽게 중첩 함수를 만들 수 있습니다.   
   
중첩 함수는 아래와 같이 코드를 정돈하는데 사용할 수 있습니다.
```
function sayHiBye(firstName, lastName) {
  function getFullName() {
    return firstName + " " + lastName;
  }

  alert("Hello, " + getFullName() );
  alert("Bye, " + getFullName() );
}
```
위 예시에서 외부 변순에 접근해 이름 전체를 반환해주는 중첩함수 `getFullName()`은 편의상 만든 함수 입니다. 이렇게 자바스크립트에선 중첩 함수가 흔히 사용됩니다.   
   
중첩 함수는 새로운 객체의 프로퍼티 형태나 중첩 함수 그 자체로 반환될 수 있다는 점에서 흥미롭습니다. 이렇게 반환된 중첩 함수는 어디서든 호출해 사용할 수 있습니다. 물론 이때도 외부 변수에 접근할 수 있다는 사실은 변함이 없습니다.   
   
아래 함수 `makeCounter`는 호출될 때마다 다음 숫자를 반환해주는 '카운터' 함수를 만듭니다.
```
function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() );  // 0
alert( counter() );  // 1
alert( counter() );  // 2
```
예시의 `makeCounter`는 아주 단순하지만, 여기에 약간의 변형을 가하면 난수 생성기 같은 실용성 있는 함수를 만들 수 있습니다.   
   
그런데 `makeCounter`를 살펴보다 보면 "`counter`를 여러 개 만들었을 때, 이 함수들은 서로 독립적일까? 함수와 중첩 함수 내 `count` 변수엔 어떤 값이 할당될까?" 같은 의문이 들기 마련입니다.   



## 렉시컬 환경

명확한 이해를 돕기 위해 설명을 몇 개의 단계로 나눠서 진행하겠습니다.



### 단계 1. 변수
   
자바스크립트에선 실행중인 함수, 코드 블록 `{...}`, 스크립트 전체는 렉시컬 환경 이라 불리는 내부 숨김 연관 객체를 갖습니다.   
   
렉시컬 환경 객체는 두 부분으로 구성됩니다.
   
1. 환경 레코드(Environment Record) - 모든 지역 변수를 프로퍼티로 저장하고 있는 객체 입니다. `this`값과 같은 기타 정보도 여기에 저장됩니다.
2. 외부 렉시컬 환경(Outer Lexical Environment)에 대한 참조 - 외부 코드와 연관됨

'변수'는 특수 내부 객체인 `환경 레코드`의 프로퍼티일 뿐입니다. '변수를 가져오거나 변경'하는 것은 '환경 레코드의 프로퍼티를 가져오거나 변경'함을 의미합니다.   
   
아래 두 줄짜리 코드엔 렉시컬 환경이 하나만 존재합니다.

```
let phrase = "Hello";  // phrase: "Hello"(Lexical Environment) -> null (outer)
alert(phrase);
```

이렇게 스크립트 전체와 관련된 렉시컬 환경은 전역 렉시컬 환경(global Lexical Environment)이라고 합니다.   
   
위 코드에서 주석은 변수가 저장되는 환경 레코드를 나타내고 화살표는 외부 렉시컬 환경에 대한 참조를 나타냅니다. 전역 렉시컬 환경은 외부 참조를 갖지 않기 때문에 화살표가 `null`을 가리키는 걸 확인할 수 있습니다.   
   
코드가 실행되고  실행 흐름이 이어져 나가면서 렉시컬 환경은 변화합니다.   

```
execution start     // phrase: <uninitialized> -> null
let pharse;       // phrase: undefined
phrase = "Hello"; // phrase: "Hello"
phrase = "Bye";   // phrase: "Bye"
```
우측의 주석들은 코드가 한 줄, 한 줄 실행될 때마다 전역 렉시컬 환경이 어떻게 변화하는지 보여줍니다.   
   
1. 스크립트가 시작되면 스크립트 내에서 선언한 변수 전체가 렉시컬 환경에 올라갑니다.
  - 이때 변수의 상태는 특수 내부 상태인 'uninitialized'가 됩니다. 자바스크립트 엔진은 uninitialized 상태의 변수를 인지하긴 하지만, `let`을 만나기 전까진 이 변수를 참조할 수 없습니다.
2. `let phrase`가 나타났네요. 아직 값을 할당하기 전이기 때문에 프로퍼티 값은 `undefined`입니다.`phrase`는 이 시점 이후부터 사용할 수 있습니다.
3. `phrase'에 값이 할당되었습니다.
4. `phrase`의 값이 변경되었습니다.

지금까지 배운 내용을 요약하면
- 변수는 특수 내부 객체인 환경 레코드의 프로퍼티입니다. 환경 레코드는 현재 실행 중인 함수와 코드 블록, 스크립트와 연관되어 있습니다.
- 변수를 변경하면 환경 레코드의 프로퍼티가 변경됩니다.
   
❕렉시컬 환경은 명세서에만 존재합니다.   
'렉시컬 환경'은 명세서에서 자바스크립트가 어떻게 동작하는지 설명하는 데 쓰이는 '이론상의' 객체입니다. 따라서 코드를 사용해 직접 렉시컬 환경을 얻거나 조작하는 것은 불가능합니다.   
자바스크립트 엔진들은 명세서에 언급된 사항을 준수하면서 엔진의 고유의 방법을 사용해 렉시컬 환경을 최적화합니다. 사용하지 않는 변수를 버려 메모리를 절약하거나 다양한 내부 트릭을 써서 말이죠.

   
### 단계 2. 함수 선언문
   
함수는 변수와 마찬가지로 값입니다.   
   
다만 함수 선언문으로 선언한 함수는 일반 변수와는 달리 바로 초기화된다는 점에서 차이가 있습니다.   
   
함수 선언문으로 선언한 함수는 렉시컬 환경이 만들어지는 즉시 사용할 수 없습니다. 변수는 `let`을 만나 선언이 될 때까지 사용할 수 없지만 말이죠.   
   
선언되기 전에도 함수를 사용할 수 있는 것은 바로 이 때문입니다.   
   
아래 코드는 스크립트에 함수를 추가 했을 때 전역 렉시컬 환경 초기 상태가 어떻게 변하는지 보여줍니다.
```
execution start             // phrase: <uninitialized>, say: function -> null
let phrase = "Hello"   // ...

function say(name) {
  alert( `${phrase}, ${name}` );
}
```
이런 동작 방식은 함수 선언문으로 정의한 함수에만 적용됩니다. `let say = function(name)...` 같이 함수를 변수에 할당한 함수 표현식은 해당하지 않습니다.   


### 단계 3. 내부와 외부 렉시컬 환경
   
함수를 호출해 실행하면 새로운 렉시컬 환경이 자동으로 만들어집니다. 이 렉시컬 환경엔 함수 호출 시 넘겨받은 매개변수와 함수의 지역 변수가 저장됩니다.
