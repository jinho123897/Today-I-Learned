# call/apply와 데코레이터, 포워딩
   
자바스크립트는 함수를 다룰때 탁월한 유연성을 제공합니다. 함수는 이곳저곳 전달될 수 있고, 객체로도 사용될 수 있습니다. 이번 챕터에선 함수 간에 호출을 어떻게 포워딩하는지, 함수를 어떻게 데코레이팅 하는지에 대해 알아보겠습니다.   
   


## 코드 변경 없이 캐싱 기능 추가하기
   
CPU를 많이 잡아먹지만 결과는 안정적인 함수 `slow(x)`가 있다고 가정해 봅시다. 결과가 안정적이라는 말은 `x`가 같으면 호출 결과도 같다는 것을 의미합니다.   
   
`slow(x)`가 자주 호출된다면, 결과를 어딘가에 저장해 재연산에 걸리는 시간을 줄이고 싶을 겁니다.   
   
아래 예시에선 `slow()`안에 캐싱 관련 코드를 추가하는 대신, 래퍼 함수를 만들어 캐싱 기능을 추가할 예정입니다. 곧 정리하겠지만, 이렇게 래퍼 함수를 만들면 여러가지 이점이 있습니다.   

```
function slow(x) {
  // CPU 집약적인 작업이 여기에 올 수 있습니다.
  alert(`slow(${x})을/를 호출함`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {  // cache에 해당 키가 있으면
      return cache.get(x);  // 대응하는 값을 cache에서 읽어옵니다.
    }

    let result = func(x);  // 그렇지 않은 경우엔 func를 호출하고,

    cache.set(x, result);  // 그 결과를 캐싱(저장)합니다.
    return result;
  };
}

slow = cachingDecorator(slow);

alert( slow(1) ); // slow(1)이 저장되었습니다.
alert( "다시 호출: " + slow(1) );  // 동일한 결과

alert( slow(2) );  // slow(2)가 저장되었습니다.
alert( "다시 호출: " + slow(2) );  // 윗줄과 동일한 결과
```
