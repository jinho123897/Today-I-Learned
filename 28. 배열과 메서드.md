# 배열과 메서드
배열은 다양한 메서드를 제공합니다. 학습 편의를 위해 본 챕터에선 메서드 몇 개의 그룹으로 나눠소개하도록 하겠습니다.


## 요소 추가,제거 메서드
배열의 맨 앞이나 끝에 요소를 추가하거나 제거하는 메서드는 이미 학습한 바 있습니다.
- `arr.push(..items)` - 맨 끝에 요소 추가
- `arr.pop()` - 맨 끝 요소 제거
- `arr.shift()` - 맨 앞 요소 제거
- `arr.unshift()` - 맨 앞에 요소 추가
이 외에 요소 추가와 제거에 관련된 메서드를 알아봅시다.


### splice
배열에서 요소를 하나만 지우고 싶다면 어떻게 해야 할까요?   
   
배열 역시 객체형에 속하므로 프로퍼티를 지울 때 쓰는 연산자 `delete`를 사용해 볼 수 있습니다.
```
let arr = ["I", "go", "home"];
delete arr[1]; // "go"를 삭제합니다.
alert( arr[1] );  // undefined
alert( arr.length ); // 3
```
원하는 대로 요소를 지웠지만 배열의 요소는 여전히 세개이네요. `arr.length == 3`을 통해 이를 확인할 수 있습니다.   
   
이는 자연스러운 결과입니다. `delete obj.key`는 `key`를 이용해 해당 키에 상응하는 값을 지우기 때문이죠. `delete`메서드는 제 역할을 다 한 것입니다. 그런데 우리는 삭제된 요소가 만든 빈 공간을 나머지 요소들이 자동으로 채울 것이라 기대하며 이 메서드를 썻습니다. 배열의 길이가 더 짧아지길 기대하며 말이죠. 이런 기대를 충족하려면 특별한 메서드를 사용해야 합니다.   
   

arr.splice(start)는 요소를 자유자재로 다룰 수 있게 해주죠. 이 메서드를 사용하면 요소 추가, 삭제, 교체가 모두 가능합니다.
```
arr.splice(index[, deleteCount, elem1, ...]);
```
첫 번째 매개변수는 조작을 가할 첫 번째 요소를 가리키는 `인덱스`입니다. 두번째 매개변수는 제거하고자 하는 요소의 개수를 나타냅니다. 그 후에 오는 매개 변수는 배열에 추가할 요소를 나타냅니다.   
```
let arr = ["I", "study", "JavaScript"];
arr.splice(1, 1);  // 인덱스 1부터 요소 한 개를 제거
alert( arr ); // I, JavaScript
```
다음 예시에선 요소 세 개를 지우고, 그 자리를 다른 요소 두 개로 교체해 보도록 하겠습니다.
```
let arr = ["I", "study", "JavaScript", "right", "now"];
arr.splice(0, 3, "Let's", "dence");
alert( arr );  // Let's, dence, right, now
```
`splice`는 삭제된 요소로 구성된 배열을 반환합니다. 아래 예시를 통해 확인해 봅시다.
```
let arr = ["I", "study", "JavaScript", "right", "now"];
let removed = arr.splice(0, 2);
alert( removed );  // I, study 삭제된 요소로 구성된 배열
```
`splice`메서드의 `deleteCount`를 `0`으로 설정하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있습니다.
```
let arr = ["I", "study", "JavaScript"];

arr.splice(2, 0, "complex", "language");

alert( arr );  // I, study, complex, language, JavaScript
```
   
❕음수 인덱스도 사용할 수 있습니다.   
slice 메서드 뿐만 아니라 배열 관련 메서드엔 음수 인덱스를 사용할 수 있습니다. 이때 마이너스 부호 앞의 숫자는 배열 끝에서부터 센 요소 위치를 나타냅니다. 아래와 같이 말이죠.
```
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert( arr );  // 1, 2, 3, 4, 5
```


### slice
arr.slice는 `arr.splice`와 유사해 보이지만 훨씬 간단합니다.
```
arr.slice([start], [end]);
```
이 메서드는 `start` 인덱스부터 (`end`를 제외한)`"end"`인덱스까지의 요소를 복사한 새로운 배열을 반환합니다. `start`와 `end`는 둘 다 음수일 수 있는데 이땐, 배열 끝에서부터의 요소 개수를 의미합니다.   
   
`arr.slice`는 문자열 메서드인 `str.slice`와 유사하게 동작하는데 `arr.slice`는 서브 문자열 대신 서브 배열(subarray)을 반환한다는 점이 다릅니다.
```
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) );  // e, s (인덱스가 1인 요소부터 3인요소 까지 복사)
alert( arr.slice(-2) ); // s, t (인덱스가 -2이 요소부터 제일 끝 요소까지 복사)
```
`arr.slice()`는 인수를 하나도 넘기지 않고 호출하여 `arr`의 복사본을 만들 수 있습니다. 이런 방식은 기준의 배열을 건드리지 않으면서 배열을 조작해 새로운 배열을 만들고자 할 때 자주 사용됩니다.


### concat
arr.concat은 기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고자 할 때 사용할 수 있습니다.
```
arr.concat(arg1, arg2...)
```
인수엔 배열이나 값이 올 수 있는데, 인수 개수엔 제한이 없습니다.   
   
메서드를 호출하면 `arr`에 속한 모든 요소와 `arg1`, `arg2`등에 속한 모든 요소를 한데 모은 새로운 배열이 반환됩니다.   
   
인수 `argN`가 배열일 경우 배열의 모든 요소가 복사됩니다. 그렇지 않은 경우(단순 값인 경우)는 인수가 그대로 복사됩니다.
```
let arr = [1, 2];
alert( arr.concat([3,4]) );  // 1, 2, 3, 4
alert( arr.concat([3, 4], [5, 6] );  // 1, 2, 3, 4, 5, 6
alert( arr.concat([3, 4], 5, 6 );  // 1, 2, 3, 4, 5, 6
```
`concat`메서드는 제공받은 배열의 요소를 복사해 활용합니다. 객체가 인자로 넘어오면 객체는 분해되지 않고 통으로 복사되어 더해집니다.
```
let arr = [1, 2];
let arrayLike = {
  0: "something",
  length: 1
};
alert( arr.concat(arrayLike) );  // 1,2,[object Object]
```
그런데 인자로 받은 유사 배열 객체에 특수한 프로퍼티 `Symbol.isConcatSpreadable`이 있으면 `concat`은 이 객체를 배열처럼 취급합니다. 따라서 객체 전체가 아닌 객체 프로퍼티의 값이 더해집니다.
```
let arr = [1, 2];
let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable] : true,
  length: 2
};
alert( arr.concat(arrayLike) ); // 1,2,something,else
```
