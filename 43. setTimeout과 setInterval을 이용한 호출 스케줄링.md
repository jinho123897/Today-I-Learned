# setTimeout과 setInterval을 이용한 호출 스케줄링

일정 시간인 지난 후에 원하는 함수를 예약 실행할 수 있게 하는 것을 '호출 스케줄링'이라고 합니다.   
   
호출 스케줄링을 구현하는 방법은 두가지가 있습니다.
- `setTimeout`을 이용해 일정 시간이 지난 후에 함수를 실행하는 방법
- `setInterval`을 이용해 일정 시간 간격을 두고 함수를 실행하는 방법

자바스크립트 명세서엔 `setTimeout`과 `setInterval`가 명시되어있지 않습니다. 하지만 시중에 나와 있는 모든 브라우저, Node.js를 포함한 자바스크립트 호스트 환경 대부분이 이와 유사한 메서드와 내부 스케줄러를 지원합니다.
   


## setTimeout
   
```
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
   
매개변수:   
   
`func|code`   
실행하고자 하는 코드로, 함수 또는 문자열 형태입니다. 대개는 이 자리에 함수가 들어갑니다. 하위 호환성을 위해 문자열도 받을 수 있게 해놓았지만 추천하진 않습니다.   
   
`delay`   
실행 전 대기 시간으로, 단위는 밀리초(millisecond, 1000밀리초 = 1초)이며 기본값은 0입니다.   
   
`arg1`, `arg2`...   
함수에 전달할 인수들로, IE9 이하에서 지원하지 않습니다.   
   
예시를 통해 `setTimeout`을 어떻게 쓸 수 있는지 알아봅시다. 아래 코드를 실행하면 1초 후에 `sayHi()`가 호출됩니다.
```
function sayHi() {
  alert('안녕하세요.');
}

setTimeout(sayHi, 1000);
```
아래와 같이 함수에 인수를 넘겨줄 수도 있습니다.
```
function sayHi(who, phrase) {
  alert( who + '님, ' + phrase );
}

setTimeout(sayHi, 1000, "홍길동", "안녕하세요.");  // 홍길동 님, 안녕하세요.
```

`setTimeout`의 첫 번째 인수가 문자열이면 자바스크립트는 이 문자열을 이용해 함수를 만듭니다.   
   
아래 예시가 정상적으로 동작하는 이유이죠.
```
setTimeout("alert('안녕하세요.')", 1000);
```
그런데 이렇게 문자열을 사용하는 방법은 추천하지 않습니다. 되도록 다음 예시와 같이 익명 화살표 함수를 사용하세요.
```
setTimeout(()=> alert('안녕하세요.'), 1000);
```
   
❕함수를 실행하지 말고 넘기세요.   
초보 개발자는 `setTimeout`에 함수를 넘길 때, 함수 뒤에 `()`을 붙이는 실수를 하곤 합니다.
```
setTimeout(sayHi(), 1000);
```
`setTimeout`은 함수의 참조 값을 받도록 정의되어 있는데 `sayHi()`를 인수로 전달하면 함수 실행 결과가 전달되어 버립니다. 그런데 `sayHi()`엔 반환문이 없습니다. 호출 결과는 `undefined`가 되겠죠. 따라서 `setTimeout`은 스케줄링할 대상을 찾지 못해 원하는 대로 코드가 동작하지 않습니다.   
   


## clearTimeout으로 스케줄링 취소하기
   
`setTimeout`을 호출하면 '타이머 식별자'가 반환됩니다. 스케중링을 취소하고 싶을 땐 이 식별자(아래 예시에서 `timerId`)를 사용하면 됩니다.   
   
```
let timerId = setTimeout(...);
clearTimeour(timerId);
```
아래 예시는 함수 실행을 계획해 놓았다가 중간에 마음이 바뀌어 계획해 놓았던 것을 취소한 상황을 코드로 표현하고 있습니다. 예시를 실행해도 스케줄링이 취소되었기 때문에 아무런 변화가 없는 것을 확인할 수 있습니다.
```
let timerId = setTimeout(() => alert("아무런 일도 일어나지 않습니다.", 1000);
alert(timerId);  // 타이머 식별자

clearTimeout(timerId);
alert(timerId); // 위 탕머 식별자와 동일함 (취소 후에도 식별자와 값은 null이 되지 않습니다.)
```
예시를 실행하면 `alert`창이 2개가 뜨는데, 이 얼럿창을 통해 브라우저 환경에선 타이머 식별자가 숫자라는 걸 알 수 있습니다. 다른 호스트 환경에선 타이머 식별자가 숫자형 이외의 자료형일 수 있습니다. 참고로 Node.js에서 `setTimeout`을 실행하면 타이머 객체가 반환합니다.   
   
다시 한번 말씀드리자면, 스케줄링에 관한 명세는 따로 존재하지 않습니다. 명세가 없기 때문에 호스트 환경마다 약간의 차이가 있을 수밖에 없습니다.

참고로 브라우저는 HTML5의 timers section을 준수하고 있습니다.   
   


## setInterval
   
`setInterval`메서드는 `setTimeout`과 동일한 문법을 사용합니다.

```
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```

인수 역시 동일합니다. 다만, `setTimeout`이 함수를 단 한 번만 실행하는 것과 달리 `setInterval`은 함수를 주기적으로 실행하게 만듭니다.   
   
함수 호출을 중단하려면 `clearInterval(timerId)`을 사용하면 됩니다.   
   
다음 예시를 실행하면 메시지가 2초 간격으로 보이다가 5초 이후에는 더 이상 메시지가 보이지 않습니다.
```
// 2초 간격으로 메시지를 보여줌
let timerId = setInterval(()=> alert('째깍'), 2000);

// 5초 후에 정지
setTimeout(()=>{clearInterval(timerId); alert('정지'); }, 5000);
```
   
❕`alert`창이 떠 있더라도 타이머는 멈추지 않습니다.   
Chrome과 Firefox를 포함한 대부분의 브라우저는 `alert/confirm/prompt` 창이 떠있는 동안에도 내부 타이머를 멈추지 않습니다.   
위 예시를 실행하고 첫 번째 `alert`창이 떴을 때 몇 초간 기다렸다가 창을 닫으면, 두 번째 `alert`창이 바로 나타나는 것을 확인할 수 있습니다. 이런 이유로 얼럿 창은 명시한 지연 시간인 2초보다 더 짧은 간격으로 뜨게 됩니다.
