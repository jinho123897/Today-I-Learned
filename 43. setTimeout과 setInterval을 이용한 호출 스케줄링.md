# setTimeout과 setInterval을 이용한 호출 스케줄링

일정 시간인 지난 후에 원하는 함수를 예약 실행할 수 있게 하는 것을 '호출 스케줄링'이라고 합니다.   
   
호출 스케줄링을 구현하는 방법은 두가지가 있습니다.
- `setTimeout`을 이용해 일정 시간이 지난 후에 함수를 실행하는 방법
- `setInterval`을 이용해 일정 시간 간격을 두고 함수를 실행하는 방법

자바스크립트 명세서엔 `setTimeout`과 `setInterval`가 명시되어있지 않습니다. 하지만 시중에 나와 있는 모든 브라우저, Node.js를 포함한 자바스크립트 호스트 환경 대부분이 이와 유사한 메서드와 내부 스케줄러를 지원합니다.
   


## setTimeout
   
```
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
   
매개변수:   
   
`func|code`   
실행하고자 하는 코드로, 함수 또는 문자열 형태입니다. 대개는 이 자리에 함수가 들어갑니다. 하위 호환성을 위해 문자열도 받을 수 있게 해놓았지만 추천하진 않습니다.   
   
`delay`   
실행 전 대기 시간으로, 단위는 밀리초(millisecond, 1000밀리초 = 1초)이며 기본값은 0입니다.   
   
`arg1`, `arg2`...   
함수에 전달할 인수들로, IE9 이하에서 지원하지 않습니다.   
   
예시를 통해 `setTimeout`을 어떻게 쓸 수 있는지 알아봅시다. 아래 코드를 실행하면 1초 후에 `sayHi()`가 호출됩니다.
```
function sayHi() {
  alert('안녕하세요.');
}

setTimeout(sayHi, 1000);
```
아래와 같이 함수에 인수를 넘겨줄 수도 있습니다.
```
function sayHi(who, phrase) {
  alert( who + '님, ' + phrase );
}

setTimeout(sayHi, 1000, "홍길동", "안녕하세요.");  // 홍길동 님, 안녕하세요.
```

`setTimeout`의 첫 번째 인수가 문자열이면 자바스크립트는 이 문자열을 이용해 함수를 만듭니다.   
   
아래 예시가 정상적으로 동작하는 이유이죠.
```
setTimeout("alert('안녕하세요.')", 1000);
```
그런데 이렇게 문자열을 사용하는 방법은 추천하지 않습니다. 되도록 다음 예시와 같이 익명 화살표 함수를 사용하세요.
```
setTimeout(()=> alert('안녕하세요.'), 1000);
```
   
❕함수를 실행하지 말고 넘기세요.   
초보 개발자는 `setTimeout`에 함수를 넘길 때, 함수 뒤에 `()`을 붙이는 실수를 하곤 합니다.
```
setTimeout(sayHi(), 1000);
```
`setTimeout`은 함수의 참조 값을 받도록 정의되어 있는데 `sayHi()`를 인수로 전달하면 함수 실행 결과가 전달되어 버립니다. 그런데 `sayHi()`엔 반환문이 없습니다. 호출 결과는 `undefined`가 되겠죠. 따라서 `setTimeout`은 스케줄링할 대상을 찾지 못해 원하는 대로 코드가 동작하지 않습니다.   
   


## clearTimeout으로 스케줄링 취소하기
   
`setTimeout`을 호출하면 '타이머 식별자'가 반환됩니다. 스케중링을 취소하고 싶을 땐 이 식별자(아래 예시에서 `timerId`)를 사용하면 됩니다.   
   
```
let timerId = setTimeout(...);
clearTimeour(timerId);
```
아래 예시는 함수 실행을 계획해 놓았다가 중간에 마음이 바뀌어 계획해 놓았던 것을 취소한 상황을 코드로 표현하고 있습니다. 예시를 실행해도 스케줄링이 취소되었기 때문에 아무런 변화가 없는 것을 확인할 수 있습니다.
```
let timerId = setTimeout(() => alert("아무런 일도 일어나지 않습니다.", 1000);
alert(timerId);  // 타이머 식별자

clearTimeout(timerId);
alert(timerId); // 위 탕머 식별자와 동일함 (취소 후에도 식별자와 값은 null이 되지 않습니다.)
```
예시를 실행하면 `alert`창이 2개가 뜨는데, 이 얼럿창을 통해 브라우저 환경에선 타이머 식별자가 숫자라는 걸 알 수 있습니다. 다른 호스트 환경에선 타이머 식별자가 숫자형 이외의 자료형일 수 있습니다. 참고로 Node.js에서 `setTimeout`을 실행하면 타이머 객체가 반환합니다.   
   
다시 한번 말씀드리자면, 스케줄링에 관한 명세는 따로 존재하지 않습니다. 명세가 없기 때문에 호스트 환경마다 약간의 차이가 있을 수밖에 없습니다.

참고로 브라우저는 HTML5의 timers section을 준수하고 있습니다.   
   


## setInterval
   
`setInterval`메서드는 `setTimeout`과 동일한 문법을 사용합니다.

```
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```

인수 역시 동일합니다. 다만, `setTimeout`이 함수를 단 한 번만 실행하는 것과 달리 `setInterval`은 함수를 주기적으로 실행하게 만듭니다.   
   
함수 호출을 중단하려면 `clearInterval(timerId)`을 사용하면 됩니다.   
   
다음 예시를 실행하면 메시지가 2초 간격으로 보이다가 5초 이후에는 더 이상 메시지가 보이지 않습니다.
```
// 2초 간격으로 메시지를 보여줌
let timerId = setInterval(()=> alert('째깍'), 2000);

// 5초 후에 정지
setTimeout(()=>{clearInterval(timerId); alert('정지'); }, 5000);
```
   
❕`alert`창이 떠 있더라도 타이머는 멈추지 않습니다.   
Chrome과 Firefox를 포함한 대부분의 브라우저는 `alert/confirm/prompt` 창이 떠있는 동안에도 내부 타이머를 멈추지 않습니다.   
위 예시를 실행하고 첫 번째 `alert`창이 떴을 때 몇 초간 기다렸다가 창을 닫으면, 두 번째 `alert`창이 바로 나타나는 것을 확인할 수 있습니다. 이런 이유로 얼럿 창은 명시한 지연 시간인 2초보다 더 짧은 간격으로 뜨게 됩니다.
   


## 중첩 setTimeout
   
무언가를 일정 간격을 두고 실행하는 방법에는 크게 2가지가 있습니다.   
   
하나는 `setInterval`을 이용하는 방법이고, 다른 하나는 아래 예시와 같이 중첩 `setTimeout`을 이용하는 방법입니다.

```
/** setInterval을 이용하지 않고 아래와 같이 중첩 setTimeout을 사용함
let timerId = setInterval( ()=> alert('째깍'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('째깍');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

다섯 번째 줄의 `setTimeout`은 `(*)`로 표시한 줄의 실행이 종료되면 다음 호출을 스케줄링합니다.   
   
중첩 `setTimeout`을 이용하는 방법은 `setInterval`을 사용하는 방법보다 유연합니다. 호출 결과에 따라 다음 호출을 원하는 방식으로 조정해 스케줄링 할 수 있기 때문입니다.   
   
5초 간격으로 서버에 요청을 보내 데이터를 얻는다고 가정해 봅시다. 서버가 과부하 상태라면 요청 간격을 10초, 20초, 40초 등으로 증가시켜주는 게 좋을 겁니다.   
  
아래는 이를 구현한 의사 코드입니다.

```
let delay = 5000;

let timerId = setTimeout(function request() {
  ...요청 보내기...

  if (서버 과부하로 인한 요청 실패) {
    // 요청 간격을 늘립니다.
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);
```
CPU 소모가 많은 작업을 주기적으로 실행하는 경우에도 `setTimeout`을 재귀 실행하는 방법이 유용합니다. 작업에 걸리는 시간에 따라 다음 작업을 유동적으로 계획할 수 있기 때문입니다.   
   
중첩 `setTimeout`을 이용하는 방법은 지연 간격을 보장하지만 `setInterval`은 이를 보장하지 않습니다.   
   
아래 두 예시를 비교해 봅시다. 첫 번째 예시에선 `setInterval`을 이용했습니다.

```
let i = 1;
setInterval(function() {
  func(i++);
}, 100);
```
두 번째 예시에선 중첩 `setTimeout`을 이용했습니다.
```
let i = 1;
setTimeout(function run() {
  func(i++);
  setTimeout(run, 100);
}, 100);
```
첫 번째 예시에선, 내부 스케줄러가 `func(i++)`를 100밀리초마다 실행합니다.   
   
`setInterval`을 사용하면 `func`호출 사이의 지연 간격이 실제 명시한 간격(100ms)보다 짧아집니다!   
   
이는 `func`을 실행하는 데 '소모되는' 시간도 지연 간격에 포함시키기 때문입니다. 지극히 정상적인 동작이죠.   
   
그렇다면 `func`을 실행하는 데 걸리는 시간이 명시한 지연 간격보다 길 때 어떤 일이 발생할까요?   
   
이런 경우는 엔진이 `func`의 실행이 종료될 때까지 기다려줍니다. `func`의 실행이 종료되면 엔진은 스케줄러를 확인하고, 지연 시간이 지났으면 다음 호출을 바로 시작합니다.   
   
따라서 함수 호출에 걸리는 시간이 매번 `delay` 밀리초보다 길면, 모든 함수가 쉼 없이 게속 연속 호출됩니다.   
   
중첩 `setTimeout`을 사용하면 명시한 지연이 보장됩니다.   
   
이렇게 지연 간격이 보장되는 이유는 이전 함수의 실행이 종료된 이후에 다음 함수 호출에 대한 계획이 세워지기 때문입니다.   
   
❕가비지 컬렉션과 setInterval-setTimeout   
`setInterval`이나 `setTimeout`에 함수를 넘기면, 함수에 대한 내부 참조가 새롭게 만들어지고 이 참조 정보는 스케줄러에 저장됩니다. 따라서 해당 함수를 참조하는 것이 없어도 `setInterval`과 `setTimeout`에 넘긴 함수는 가비지 컬렉션의 대상이 되지 않습니다.
