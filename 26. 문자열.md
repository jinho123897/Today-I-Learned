# 문자열
자바스크립트엔 글자 하나만 저장할 수 있는 별도의 자료형이 없습니다. 텍스트 형식의 데이터는 길이에 상관없이 문자열 형태로 저장됩니다.   
   
자바스크립트에서 문자열은 페이지 인코딩 방식과 상관없이 항상 UTF-16형식을 따릅니다.   


## 따옴표
문자열은 작은 따옴표, 큰 따옴표, 백틱으로 감쌀 수 있습니다.   
   
작은 따옴표와 큰 따옴표는 기능상 차이가 없습니다. 그런데 백틱엔 특별한 기능이 있습니다. 표현식을 `${...}`로 감싸고 이를 백틱으로 감싼 문자열 중간에 넣어주면 해당 표현식을 문자열 중간에 쉽게 삽입할 수 있죠. 이런 방식을 템플릿 리터럴이라고 부릅니다.   
   
백틱을 사용하면 문자열을 여러 줄에 걸쳐 작성할 수도 있습니다. 작은 따옴표나 큰 따옴표를 사용하면 여러 줄짜리 문자열을 만들 수 없습니다.   
   
백틱은 '템플릿 함수'에서도 사용됩니다. `func'string'`같이 첫 번째 백틱 바로 앞에 함수 이름(`func`)을 써주면, 이 함수는 백틱 안의 문자열 조각이나 표현식 평가 결과를 인수로 받아 자동으로 호출됩니다. 이런 기능을 '테그드 템플릿'이라 부르는데, 태그드 템플릿과 템플릿 함수에 대한 자세한 내용은 MDN 문서에서 확인해보세요.


## 특수 기호
'줄 바꿈 문자'라 불리는 특수기호 `\n`을 사용하면 작은 따옴표나 큰 따옴표로도 여러 줄 문자열을 만들 수 있습니다.
```
let guestList = "손님: \n * John\n * Pete\n * Mary";
```
따옴표를 이용해 만든 여러줄 문자열과 백틱을 이용해 만든 여러 줄 문자열은 표현 방식만 다를 뿐 차이가 없습니다.
```
let str1 = "Hello\nWorld";
let str2 = `Hello
World`;

alert(str1 == str2);  // true
```
자바스크립트엔 줄 바꿈 문자를 비롯한 다양한 '특수'문자들이 있습니다.   
   
모든 특수 문자는 '이스케이프 문자'라고도 불리는 역슬래시 `\`로 시작합니다.
```

alert('I\'m the Walrus!');  // I'm the Walrus!
```
위 예시에서 살펴본 바와 같이 문자열 내의 따옴표엔 `\`를 꼭 붙여줘야합니다. 이렇게 하지 않으면 해당 따옴표가 문자열을 닫는 용도로 사용된 것이라 해석하기 때문입니다.   
   
이스케이프 문자가 아닌 백틱을 사용해서 따옴표를 사용할 수도 있습니다.
```
alert( `I'm the walrus!`);  // I'm the Walrus!
```
역슬래시를 보여줘야 하는 경우엔 `\\`같이 역슬래시를 두 개 붙이면 됩니다.


## 문자열의 길이
`length` 프로퍼티엔 문자열의 길이가 저장됩니다.
```
alert(`My\n`.length);  // 3
```
`\n`은 '특수 문자'하나로 취급되기 때문에 `My\n`의 길이는 `3`입니다.   
   
❗`length`는 프로퍼티입니다.   
`length`는 함수가 아닌고, 숫자가 저장되는 프로퍼티라는 점에 주의하시기 바랍니다. 뒤에 괄호를 붙일 필요가 없습니다.


## 특정 글자에 접근하기
문자열 내 특정 위치인 `pos`에 있는 글자에 접근하려면 `[pos]`같이 대괄호를 이용하거나 str.charAt(pos)라는 메서드를 호출하면 됩니다. 위치는 0부터 시작합니다.
```
let str = `Hello`;

alert( str[0] );  // H
alert( str.charAt(0) );  // H

alert( str[str.length - 1] );  // o
```
근래에는 대괄호를 이용하는 방식을 사용합니다. `charAt`은 하위 호환성을 위해 남아있는 메서드라고 생각하시면 됩니다.   
   
두 접근 방식의 차이는 반환할 글자가 없을 때 드러납니다. 접근하려는 위치에 글자가 없는 경우 `[]`는 `undefined`를, `charAt`은 빈 문자열을 반환합니다.   
`for..of`를 사용하면 문자열을 구성하는 글자를 대상으로 반복 작업을 할 수 있습니다.
```
for (let char of "Hello") {
  alert(char);  // H, e, l, l, o
}
```


## 문자열의 불변성
문자열은 수정할 수 없습니다. 따라서 문자열의 글자 하나를 바꾸려고 하면 에러가 발생합니다.
```
let str = 'Hi';

str[0] = 'h';  //Error: ...
alert( str[0] );  // 동작하지 않습니다.
```
이런 문제를 피하려면 완전히 새로운 문자열을 하나 만든 다음, 이 문자열을 할당하면 됩니다.


## 대소문자 변경하기
메서드 toLowerCase()와 toUpperCase()는 대문자를 소문자로, 소문자를 대문자로 변경 시켜줍니다.
```
alert( 'Interface'.toUpperCase() );  // INTERFACE
alert( 'Interface'.toLowerCase() );  // interface
```
글자 하나의 케이스만 변경하는 것도 가능합니다.
```
alert( 'Interface'[0].toLowerCase() );  // 'i'
```


## 부분 문자열 찾기
문자열에서 부분 문자열을 찾는 방법은 여러 가지가 있습니다.   
   
### str.indexOf
첫 번째 방법은 str.indexOf(substr, pos) 메서드를 이용하는 것입니다.   
   
이 메서드는 문자열의 `str`의 `pos`에서 부터 시작해, 부분 문자열 `substr`이 어디에 위치하는지를 찾아줍니다. 원하는 부분 문자열을 찾으면 위치를 반환하고 그렇지 않으면 `-1`을 반환합니다.   
```
let str = 'Widget with id';

alert( str.indexOf('Widget') );  // 0
alert( str.indexOf('widget') );  // -1, 대소문자를 구분함 원하는 문자열이 없을 경우 -1을 반환

alert( str.indexOf('id') ); // 1, Widget에 id 존재함으로 1이 반환
```
`str.indexOf(substr, pos)`의 두 번째 매개변수 `pos`는 선택적으로 사용할 수 있는데, 이를 명시하면 검색이 해당 위치부터 시작됩니다.   
```
let str = 'Widget with id';

alert( str.indexOf('id', 2) );  // 12
```
문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶다면 반복문 안에 `indexOf`를 사용하면 됩니다. 반복문이 하나씩 돌 때마다 검색 시작 위치가 갱신되면서 `indexOf`가 새롭게 호출됩니다.
```
let str = "As sly as a fox, as strong as an ox";
let target = "as";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( `위치: ${pos}` );
}
```
   
❕`str.lastIndexOf(substr, position)`   
   
str.lastIndexOf(substr, position)는 `indexOf`와 유사한 기능을 하는 메서드입니다. 문자열 끝에서부터 부분 문자열을 찾는다는 점만 다릅니다. 반환되는 부분 문자열 위치는 문자열 끝이 기준입니다.   
   
`if`문의 조건식에 `indexOf`를 쓸 때 주의할 점이 하나 있습니다. 아래와 같이 코드를 작성하면 원하는 결과를 얻을 수 없습니다.
```
let str = "Widget with id";

if (str.indexOf("Widget")) {
  alert("찾았다!");  // 의도한 대로 동작하지 않습니다.
}
```
`str.indexOf("Widget")`은 `0`을 반환하는데, `if`문에서 `0`을 `false`로 간주하므로 `alert`창이 뜨지않습니다. 따라서 부분 문자열 여부를 검사하려면 아래와 같이 `-1`과 비교해야 합니다.
```
let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
  alert("찾았다!");
}
```
   
### 비트 NOT 연산자를 사용한 기법
오래전부터 전해 오는 비트 NOT 연산자 `~`를 사용한 기법 하나를 소개해드리겠습니다. 비트 NOT 연산자는 피연산자를 32비트 정수로 바꾼 후(소수부는 모두 버려짐) 모든 비트를 반전합니다.   
   
따라서 `n`이 32비트 정수일 때 `~n`은 `-(n+1)`이 됩니다.
```
alert(~2);  // -3, -(2+1)과 같음
alert(~1);  // -2, -(1+1)과 같음
alert(~0);  // -1, -(0+1)과 같음
alert(~-1); // 0, -(-1+1)과 같음
```
위 예시에서 본 바와 같이 부호가 있는 32비트 정수 `n`중, `~n`을 `0`으로 만드는 경우는 `n == -1`일 때가 유용합니다.   
   
이렇게 `~str.indexOf("...")`를 사용하면 코드의 길이를 줄일 수 있습니다.
```
let str = "Widget";

if (~str.indexOf("Widget")) {
  alert("찾았다!")
}
```
사실 이렇게 언어 특유의 기능을 사용해 직관적이지 않은 코드를 작성하는 것을 추천해 드리진 않습니다. 그렇지만 위와 같은 기법은 오래된 스크립트에서 쉽게 만날 수 있기 때문에 알아두어야 합니다.   
   
참고로 `-1`이외에도 `~`연산자 적용 시 `0`을 반환하는 숫자는 다양합니다. 아주 큰 숫자에 `~`연산자를 적용하면 32비트 정수로 바꾸는 과정에서 잘림 현상이 발생하기 때문이죠. 이런 숫자 중에 가장 큰 숫자는 `4294967295`입니다. 문자열이 아주 길지 않은 경우에만 `~` 연산자가 의도한 대로 작동한다는 점을 알고 계시길 바랍니다.


### includes, startsWith, endsWith
비교적 근래에 나온 메서드인 str.includes(substr, pos)는 `str`에 부분 문자열 `substr`이 있는지에 따라 `true`나 `false`를 반환합니다. 부분 문자열의 위치 정보는 필요하지 않고 포함 여부만 알고 싶을 때 적합한 메서드 입니다.
```
alert( "Widget with id".includes("Widget") );  // true
alert( "Hello".includes("Bye") );  // false
```
`str.includes`에도 `str.indexOf`처럼 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색합니다.
```
alert( "Widget".includes("id", 3) );  // false
```
메서드 str.startsWith와 str.endsWith는 메서드 이름 그대로 문자열 `str`이 특정 문자열로 시작하는지 여부와 특정 문자열로 끝나는지 여부를 확인할 때 사용할 수 있습니다.
```
alert( "Widget".startsWith("Wid") );  // true, Wid로 시작함
alert( "Widget".endsWith("get") );  // true, get로 끝남
```


## 부분 문자열 추출하기
자바스크립트엔 부분 문자열 추출과 관련된 메서드가 세 가지 있습니다.   
   
`str.slice(start [, end])`   
문자열의 `start`부터 `end`까지를 반환합니다.
```
let str = "stringify";
alert( str.slice(0, 5) );  // 'strin'
alert( str.slice(0, 1) );  // 's'
```
두 번째 인수가 생략된 경우엔, 명시한 위치부터 문자열 끝까지를 반환합니다.   
`start`와 `end`는 음수가 될 수도 있습니다. 음수를 넘기면 문자열 끝에서부터 카운팅을 시작합니다.
```
let str = "stringify";
alert( str.slice(-4, -1) );  //gif
```
   
`str.substring(start [, end])`   
`start`와 `end`사이에 있는 문자열을 반환합니다.   
`substring`은 `slice`와 아주 유사하지만 `start`가 `end`보다 커도 괜찮다는 데 차이가 있습니다.
```
let str = "stringify";

alert( str.substring(2, 6) );  // "ring"
alert( str.substring(6, 2) );  // "ring"
```
`substring`은 음수 인수를 허용하지 않습니다. 음수는 `0`으로 처리됩니다.   
   
`str.substr(start, [, length])`   
`start`에서부터 시작해 `length`개의 글자를 반환합니다.   
`substr`은 끝 위치 대신에 길이를 기준으로 문자열을 추출한다는 점에서 `substring`과 `slice`와 차이가 있습니다.
```
let str = "stringify";
alert( str.substr(2, 4) ); // ring, 두번째부터 글자 네개
```
첫 번째 인수가 음수면 뒤에서부터 개수를 셉니다.
```
let str = "stringify";
alert( str.substr(-4, 2) ); // gi, 끝에서 네 번째 위치부터 글자 두개
```
   
❕어떤 메서드를 선택해야 할까요?   
모두 사용해도 괜찮습니다. 그런데 `substr`에는 단점이 하나 있습니다. `substr`는 코어 자바스크립트 명세서가 아닌, 구식 스크립트에 대응하기 위해 남겨 둔 브라우저 전용 기능들을 명시해 놓은 부록B에 정의되어 있습니다. 거의 모든 곳에서 이 메서드가 동작하긴 하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있습니다. 남은 두 메서드 중 `slice`는 음수 인수를 허용한다는 측면에서 `substring`보다 좀 더 유연합니다. 메서드 이름도 더 짧죠. 따라서 세  메서드 중 `slice`만 외워놓고 사용해도 충분할것 같습니다.
   
   
## 문자열 비교하기
비교 연산자 챕터에서 알아 보았들이 문자열을 비교할 땐 알파벳 순서를 기준으로 글자끼리 비교가 이뤄집니다. 그런데 아래와 같이 몇 가지 이상해 보이는 것들이 있습니다.
1. 소문자는 대문자보다 항상 큽니다.
```
alert( 'a' > 'Z' );  // true
```
2. 발음 구별 기호가 붙은 문자는 알파벳 순서 기준을 따르지 않습니다.
```
alert( 'Österreich' > 'Zealand' ); // true
```
   
이런 예외사항  때문에 이름순으로 국가를 나열할 때 예상치 못한 결과가 나올 수 있습니다. 사람들은 `Österreich`가 `Zealand`보다 앞서 나올 것이라 예상하는데 그렇지 않죠.   
   
모든 문자열은 UTF-16을 사용해 인코딩되는데, UTF-16에선 모든 글자가 숫자 형식의 코드와 매칭됩니다. 코드로 글자를 얻거나 글자에서 연관 코드를 알아낼 수 있는 메서드는 다음과 같습니다.   
   
`str.codePointAt(pos)`   
`pos`에 위치한 글자의 코드를 반환합니다.
```
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePoinAt(0) );  // 90
```
   
`String.fromCodePoint(code)`   
숫자 형식의 `code`에 대응하는 글자를 만들어줍니다.   
```
alert( String.fromCodePoint(90) );  // Z
```
`\u`뒤에 특정 글자에 대응하는 16진수 코드를 붙이는 방식으로 원하는 글자를 만들 수 있습니다.
```
alert( `\u005a' );  // Z
```
이제 이 배경지식을 가지고 코드 `65`와 `220`사이에 대응하는 글자들을 출력해봅시다.
```
let str = '';

for ( let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert( str );
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```
대문자 알파벳이 가장 먼저 나오고 특수 문자 몇 개가 나온 다음에 소문자 알파벳이 나오네요. `Ö`은 거의 마지막에 출력됩니다.
- 알파벳 소문자의 코드는 대문자의 코드보다 크므로 소문자는 대문자 뒤에 옵니다.
- `Ö`같은 글자는 일반 알파벳과 멀리 떨어져 있습니다. `Ö`의 코드는 알파벳 소문자의 코드보다 훨씬 큽니다.
   
   
### 문자열 제대로 비교하기
언어마다 문자 체계가 다르기 때문에 문자열을 '제대로' 비교하는 알고리즘은 만드는 건 생각보다 간단하지 않습니다.   
   
문자열을 비교하려면 일단 페이지에서 어떤 언어를 사용하고 있는지 알아야 합니다.   
   
다행히도 모던 브라우저 대부분이 국제화 표준인 ECMA_402를 지원합니다. ECMA-402엔 언어가 다를 때 적용할 수 있는 문자열 비교 규칙과 이를 준수하는 메서드가 정의되어 있습니다.   
   
str.localCompare(str2)를 호출하면 ECMA-402에서 정의한 규칙에 따라 `str`이 `str2`보다 작은지, 같은지, 큰지를 나타내주는 정수가 반환됩니다.
- `str`이 `str2`보다 작으면 음수를 반환합니다.
- `str`이 `str2`보다 크면 양수를 반환합니다.
- `str`이 `str2`이 같으면 `0`을 반환합니다.
```
alert( 'Österreich'.localeCompare('Zealand') ); // -1
```
`localeCompare`엔 선택 인수 두 개를 더 전달할 수 있습니다. 기준이 되는 언어를 지정(아무것도 지정하지 않았으면 호스트 환경의 언어가 기준 언어가 됨)해주는 인수와 대·소문자를 구분할지나 `"a"`와` "á"`를 다르게 취급할지에 대한 것을 설정해주는 인수가 더 있죠. 자세한 사항은 관련 페이지에서 확인해 보시기 바랍니다.


---
출처: 모던 JavaScript 튜토리얼 - 
