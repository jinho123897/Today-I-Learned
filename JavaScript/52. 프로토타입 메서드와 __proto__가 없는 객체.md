# 프로토타입 메서드와 __proto__가 없는 객체

이 절의 첫 번째 챕터에서 프로토타입을 설정하기 위한 모던한 방법이 있다고 언급했습니다.   
   
`__proto__`는 브라우저를 대상으로 개발하고 있다면 다소 구식이기 때문에 더는 사용하지 않는 것이 좋습니다. 표준에도 관련 내용이 명시되어있습니다.   
   
대신 아래와 같은 모던한 메서드들을 사용하는 것이 좋습니다.   

- Object.create(proto, [descriptors]) - `[[Prototype]]`이 `proto`를 참조하는 빈 객체를 만듭니다. 이때 프로퍼티 설명자를 추가로 넘길 수 있습니다.
- Object.getPrototypeOf(obj) - `obj`의 `[[Prototype]]`을 반환합니다.
- Object.setPrototypeOf(obj, proto) - `obj`의 `[[Prototype]]`이 `proto`가 되도록 설정합니다.
   
앞으론 아래 예시처럼 `__proto__`대신 메서드를 사용하도록 합시다.
```
let animal = {
  eats: true
};

// 프로토타입이 animal인 새로운 객체를 생성합니다.
let rabbit = Object.create(animal);

alert(rabbit.eats);  // true

alert(Object.getPrototypeOf(rabbit) === animal);   // true

Object.setPrototypeOf(rabbit, {});  // rabbit의 프로토타입을 {}으로 바꿉니다.
```
메서드를 소개할 때 잠시 언급한 것처럼 `Object.create`에는 프로퍼티 설명자를 선택적으로 전달할 수 있습니다. 설명자를 이용해 새 객체에 프로퍼티를 추가해 보겠습니다.
```
let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

alert(rabbit.jumps);  // true
```
설명자는 프로퍼티 플래그와 설명자에서 배운 것과 같은 형태로 사용하면 됩니다.   
   
`Object.create`를 사용하면 `for..in`을 사용해 프로퍼티를 복사하는 것보다 더 효과정으로 객체를 복제할 수 있습니다.
```
let clone = Object.create(Object.getPrototypeOf(obj), Object,getOwnPropertyDescriptors(obj));
```
`Object.create`를 호출하면 `obj`의 모든 프로퍼티를 포함한 완벽한 사본이 만들어집니다. 사본엔 열거 가능하 프로퍼티와 불가능한 프로퍼티, getter, setter등 모든 프로퍼티가 복제됩니다. `[[Prototype]]`도 복제되죠.



## 비하인드 스토리

`[[Prototype]]`을 다루는 방법은 다양합니다. 목표는 하나인데 목표를 이루기 위한 수단은 여러가지이죠. 왜 그럴까요? 역사적인 이유가 있습니다.   
   
- 생성자 함수의 `"prototype"` 프로퍼티는 아주 오래전부터 사용되고 있었습니다.
- 그런데 2012년, 명세서에 `Object.create`가 추가되었습니다. `Object.create`를 사용하면 주어진 프로토타입을 사용해 객체를 만들 수 있긴 하지만, 프로토타입을 얻거나 설정하는 것은 불가능했습니다. 그래서 브라우저는 비표준 접근자인 `__proto__`를 구현해 언제나 프로토타입을 얻거나 설정할 수 있도록 하였습니다.
- 이후 2015년에 `Object.setPrototypeOf`와 `Object.getPrototypeOf`가 표준에 추가되면서 `__proto__`와 동일한 기능을 수행할 수 있게 되었습니다. 그런데 이 시점에 `__proto__`를 사용하는 곳이 너무 많아서 `__proto__`는 사실상 표준이 되어버렸죠. 이 내용은 명세서의 부록B에 추가되어 있습니다. 부록B의 내용은 브라우저 이외의 호스트 환경에선 선택사항이라는 것을 의미합니다.
   
이런 역사적인 이유 때문에 지금은 여러 방식을 원하는 대로 쓸 수 있게되었습니다.   
   
이쯤되면 "왜 `__proto__`가 함수 `getPrototypeOf`,`setPrototypeOf`로 대체되었을까?" 라는 의문이 떠오를 수 있습니다. 흥미로운 질문이죠. 답은 `__proto`가 왜 나쁜지 이해하면 얻을 수 있습니다.   
   
❗속도가 중요하다면 기존 객체의 `[[Prototype]]`을 변경하지 마세요.   
원한다면 언제나 `[[Prototype]]`을 얻거나 설정할 수 있습니다. 기술적 제약이 있는건 아니죠. 하지만 대게는 객체를 생성할 때만 `[[Prototype]]`을 설정하고 이후엔 수정하지 않습니다. `rabbit`이 `animal`을 상속받도록 설정하고 난 이후엔 상속 관계를 잘 변경하지 않습니다.   
자바스크립트 엔진은 이런 시나리오를 토대로 최적화되어 있습니다.   
`Object.setPrototypeOf`나 `obj.__proto_=`를 써서 프로토타입을 그때그때 바꾸는 연산은 객체 프로퍼티 접근 관련 최적화를 망치기 때문에 성능에 나쁜 영향을 마칩니다. 그러므로 `[[Prototype]]`을 바꾸는 것이 어떤 결과를 초래할지 확실히 알거나 속도가 전혀 중요하지 않은 경우가 아니라면 `[[Prototyp]]`을 바꾸지 마세요.
