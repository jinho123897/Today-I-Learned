# 'try..catch'와 에러 핸들링

아무리 프로그래밍에 능한 사람이더라도 에러가 있는 스크립트를 작성할 수 있습니다. 원인은 아마도 실수, 예상치 못한 사용자 입력, 잘못된 서버 응답 등의 수천만 가지 이유 때문일 겁니다.   
   
에러가 발생하면 스크립트는 '죽고'(즉시 중단되고), 콘솔에 에러가 출력됩니다.   
   
그러나 `try..catch`문법을 사용하면 스크립트가 죽는 걸 방지하고, 에러를 '잡아서(catch)' 더 합당한 무언가를 할 수 있게 됩니다.



## 'try...catch' 문법

'try...catch'문법은 'try'와 'catch'라는 두 개의 주요 블록으로 구성됩니다.   
```
try{
  // 코드
} catch (err) {
  // 에러 핸들링
}
```
try...catch 동작 알고리즘은 다음과 같습니다.
   
1. 먼저, `try {...}`안의 코드가 실행됩니다.
2. 에러가 없다면, `try`안의 마지막 줄까지 실행되고, `catch` 블록은 건너뜁니다.
3. 에러가 있다면, `try`안 코드의 실행이 중단되고, `catch(err)`블록으로 제어 흐름이 넘어갑니다. 변수 `err`(아무 이름이나 사용 가능)는 무슨 일이 일어났는지에 대한 설명이 담긴 에러 객체를 포함합니다.   

이렇게 `try {...}` 블록 안에서 에러가 발생해도 `catch`에서 에러를 처리하기 때문에 스크립트는 죽지 않습니다.   

- 에러가 없는 예시 : `(1)`과 `(2)`를 `alert` 창에 보여줌
```
try {
  alert('try 블록 시작');  // (1)  <--
  // ... 에러가 없습니다.
  alert('try 블록 끝');  // (2)  <--
} catch(err) {
  alert('에러가 없으므로, catch는 무시됩니다.');  // (3)
}
```

- 에러가 있는 예시 : `(1)`과 `(3)`을 보여줍니다.
```
try {
  alert('try 블록 시작');  // (1) <--
  lalala;  // 에러, 변수가 정의되지 않음!
  alert('try 블록 끝(절대 도달하지 않음)');  // (2)
} catch(err) {
  alert('에러가 발생했습니다!`);  // (3)  <--
}
```
   
> ❗ `try..catch`는 오직 런타임 에러에만 동작합니다.   
`try..catch`는 실행 가능한 (runnable) 코드에만 동작합니다. 실행 가능한 코드는 유효한 자바스크립트 코드를 의미합니다.   
중괄호 짝이 안 맞는 것처럼 코드가 문법적으로 잘못된 경우엔 `try..catch`가 동작하지 않습니다.
```
try {
  {{{{{{{{{{{{
} catch(e) {
  alert("유효하지 않은 코드이기 때문에, 자바스크립트 엔진은 이 코드를 이해할 수 없습니다.");
}
```
> 자바스크립트 엔진은 코드를 읽고 난 후 코드를 실행합니다. 코드를 읽는 중에 발생하는 에러가 'parse-time 에러'라고 부르는데, 엔진은 이 코드를 이해할 수 없기 때문에 parse-time 에러는 코드 안에서 복구가 불가능합니다.   
`try..catch`는 유효한 코드에서 발생하는 에러만 처리할 수 있습니다. 이런 에러를 '런타임 에러' 혹은 '예외' 라고 부릅니다.   
   
> ❗ `try..catch`는 동기적으로 동작합니다.   
setTimeout처럼 '스케줄 된(scheduled)' 코드에서 발생한 예외는 `try..catch`에서 잡아낼 수 없습니다.   
```
try {
  setTimeout(function() {
    noSuchVariable; // 스크립트는 여기서 죽습니다.
  }, 1000);
} catch (e) {
  alert( "작동 멈춤" );
}
```
> `setTimeout`에 넘겨진 익명 함수는 엔진이 `try..catch`를 떠난 다음에서야 실행되기 때문입니다.   
스케줄 된 함수 내부의 예외를 잡으려면, `try..catch`를 반드시 함수 내부에 구현해야 합니다.
```
setTimeout(function() {
  try {
    noSuchVariable; // 이제 try..catch에서 에러를 핸들링 할 수 있습니다!
  } catch {
    alert( "에러를 잡았습니다!" );
  }
}, 1000);
```



## 에러 객체

에러가 발생하면 자바스크립트는 에러 상세내용이 담긴 객체를 생성합니다. 그 후, `catch` 블록에 이 객체를 인수로 전달합니다.   
```
try {
  // ...
} catch (err) { <-- '에러 객체', err 대신 다른 이름으로도 쓸 수 있음
  // ...
}
```

내장 에러가 전체와 에러 객체는 두 가지 주요 프로퍼티를 가집니다.   
   
`name`   
에러 이름. 정의되지 않은 변수 때문에 발생한 에러라면 `"ReferenceError"`가 이름이 됩니다.   
   
`message`   
에러 상세 내용을 담고 있는 문자 메시지
   
표준은 아니지만, `name`과 `message` 이외에 대부분의 호스트 환경에서 지원하는 프로퍼티도 있습니다. `stack`은 가장 널리 사용되는 비표준 프로퍼티 중 하나입니다.   
   
`stack`   
현재 호출 스택. 에러를 유발한 중첩 호출들의 순서 정보를 가진 문자열로 디버깅 목적으로 사용됩니다.   
   
```
try {
  lalala;  // 에러, 변수가 정의되지 않음!
} catch(err) {
  alert(err.name);  // ReferenceError
  alert(err.message);  // lalala is not defined
  alert(err.stack);  // ReferenceError: lalala is not defined at...

  // 에러 전체를 보여줄 수도 있습니다.
  // 이때, 에러 객체는 "name: message" 형태의 문자열로 변환됩니다.
  alert(err);   // ReferenceError: lalala is not defined
}
```



## 선택적 'catch' 바인딩

에러에 대한 자세한 정보가 필요하지 않으면, `catch`에서 이를 생략할 수 있습니다.
```
try {
  // ...
} catch {  // <-- (err) 없이 쓸 수 있음
  // ...
}
```



## 'try...catch' 사용하기

`try..catch`가 실무에서 어떻게 사용되는지 알아봅시다.   
   
앞서 JSON으로 인코딩된 값을 읽을 수 있도록 해주는 JSON.parse(str) 메서드에 배운 바 있습니다.   
   
이 메서드로 주로 서버 등에서 네트워크를 통해 전달받은 데이터를 디코딩하는 데 사용합니다.   
   
전달받은 데이터에 `JSON.parse`를 호출하는 식으로 사용되죠.
   
```
let json = '{"name": "John", "age": 30}';  // 서버로부터 전달받은 데이터

let user = JSON.parse(json);  // 전달받은 문자열을 자바크립트 객체로 변환

// 문자열 형태로 전달받은 user가 프로퍼티를 가진 객체가 됨
alert( user.name );  // John
alert( user.age );  // 30
```

JSON에 관한 자세한 정보는 JSON과 메서드 챕터에서 읽어보시기 바랍니다.   
   
잘못된 형식의 `json`이 들어온 경우, `JSON.parse`는 에러를 만들기 때문에 스크립트가 죽습니다.   
   
서버에 전달받은 데이터가 잘못되어 스크립트가 죽는 경우, 사용자는 개발자 콘솔을 열리 않는 이상 절대 원인을 알수 없습니다. 그런데 사람들은 메시지등을 통해 에러의 원인을 알지 못한 채 무언가가 그냥 죽는 것을 정말 싫어합니다.   
   
`try..catch`를 사용해 이를 처리해 봅시다.
```
let json = "{ bad json}";

try {
  let user = JSON.parse(json);  // <-- 여기서 에러가 발생하므로
  alert( user.name );   // 이 코드는 동작하지 않습니다.
} catch (e) {
  // 에러가 발생하면 제어 흐름이 catch 문으로 넘어옵니다.
  alert( "데이터에 에러가 있어 재요청을 시도합니다.");
  alert( e.name );
  alert( e.message );
}
```

위 예시에선 에러가 발생했다는 걸 보여주기 위해 간단히 예외처리 했지만, `catch` 블록 안에서 새로운 네트워크 요청 보내기, 사용자에세 대안 제안하기, 로깅 장치에 에러 정보 보내기 등과 같은 구체적인 일을 할 수 있습니다. 스크립트가 죽도록 놔두는 것보다 훨씬 나은 대응이죠.



## 직접 에러를 만들어서 던지기

`json`이 문법적으로 잘못되진 않았지만, 스크립트 내에서 사용 중인 필수 프로퍼티 `name`을 가지고 있지 않다면 무슨 일이 생길까요?

```
let json = '{ "age": 30 }';  // 불완전한 데이터

try {
  let user = JSON.parse(json);  // <-- 에러 없음
  alert( user.name );  // 이름이 없습니다!
} catch (e) {
  alert("실행되지 않습니다.");
}
```
위 예시에서 `JSON.parse`는 정상적으로 실행되었지만 `name`이 없는 건 에러를 유발하는 상황입니다.   
   
이제 `throw` 연산자를 사용해 에러 처리를 통합해 보도록 하겠습니다.
