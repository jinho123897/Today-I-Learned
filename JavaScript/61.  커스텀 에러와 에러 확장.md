# 커스텀 에러와 에러 확장

개발을 하다 보면 자체 에러 클래스가 필요한 경우가 종종 생깁니다. 네트워크 관련 작업 중 에러가 발생했다면 `HttpError`, 데이터 베이스 관련 작업 중 에러가 발생했다면 `DbError`, 검색 관련 작업 중 에러가 발생했다면 `NotFoundError`를 사용하는 것이 직관적이기 때문이죠.   
   
직접 에러 클래스를 만든 경우, 이 에러들은 `message`이나 `name`, 가능하다면 `stack`프로퍼티를 지원해야 합니다. 물론 이런 프로퍼티 이외에도 다른 프로퍼티를 지원할 수 있습니다. `HttpErorr`클래스의 객체에 `statusCode` 프로퍼티를 만들고 `404`나 `403`, `500`같은 숫자를 값으로 지정할 수 있을 겁니다.   
   
앞서 배운 바와 같이 `throw`의 인수엔 아무런 제약이 없기 때문에 커스텀 에러 클래스는 반드시 `Error`를 상속할 필요가 없습니다. 그렇지만 `Error`를 상속받아 커스텀 에러 클래스를 만들게 되면 `obj instanceof Error`를 사용해서 에러 객체를 식별할 수 있다는 장점이 생깁니다. 이런 장점 때문에 맨땅에 커스텀 에러 객체를 만드는 것보다 `Error`를 상속받아 에러 객체를 만드는 것이 낫습니다.   
   
애플리케이션 크기가 점점 커지면 우리가 만들게 될 커스텀 에러 클래스들은 자연스레 계층 구조를 형성하게 됩니다. `HttpTimeoutError`는 `HttpError`를 상속받는 식으로 말이죠.



## 에러 확장하기

사용자 데이터가 저장된 JSON을 읽는 함수 `readUser(json)`가 있다고 해봅시다.   
   
유효한 `json`은 다음과 같은 형태이어야 합니다.   

```
let json = `{ "name" : "John", "age" : 30 }`;
```

`readUser` 내부에선 `JSON.parse`를 이용하게 됩니다. 따라서 잘못된 형식의 `json`이 들어오면 `SyntaxError`가 발생하겠죠. 그런데 인수로 받은 데이터가 JSON 형식이긴 하지만, 유효한 사용자일 것이라는 보장은 없습니다. 사용자 데이터라면 필수적으로 있어야 할 `name`이나 `age`가 누락되었을 수 있죠.   
   
따라서 `readUser(json)`은 JSON 형식의 데이터를 읽을 수 있을 뿐만 아니라, 데이터를 '검증'할 수 있어야 합니다. 필수 프로퍼티가 없거나, 위 형식에 맞지 않으면 에러를 발생시킬 수 있어야 하죠. 그런데 이때 발생하는 에러는 `SyntaxError`가 아닙니다. JSON 형식은 맞지만, 자체 기준에 맞지 않기 때문에 발생한 에러이므로 전혀 다른 종류의 에러이죠. 지금부턴 이 에러를 `ValidationError`라고 부르겠습니다. 자 이제 `ValidationError`를 위한 클래스를 만들어봅시다.   
   
`ValidationError` 클래스엔 문제가 되는 필드 정보가 저장되어야합니다. 내장 클래스 `Error`를 상속받아 `ValidationErorr` 클래스를 만들어봅시다.   
   
그 전에 먼저 잠시 슈도 코드로 `Error`클래스가 어떻게 생겼는지 살펴보겠습니다.   
   
```
// 자바스크립트 자체 내장 에러 클래스 Erorr의 '슈도 코드'
class Error {
  constructor(message) {
    this.message = message;
    this.name = "Error";  // (name은 내장 에러 클래스마다 다릅니다.)
    this.stack = <call stack>;  // stack은 표준은 아니지만, 대다수 환경이 지원합니다.
  }
}
```

이제 `ValidationError`에서 `Error`를 상속받아보겠습니다.   

```
class ValidationError extends Error {
  constructor(message) {
    super(message);  // (1)
    this.name = "ValidationError"; // (2)
  }
}

function test() {
  throw new ValidationError("에러 발생!");
}

try {
  test();
} catch(err) {
  alert(err.message);  // 에러 발생!
  alert(err.name);  // ValidationError
  alert(err.stack);  // 각 행 번호가 있는 중첩된 호출들의 목록
}
```

`(1)`에서 부모 생성자를 호출하고 있다는 것에 주목해 주시기 바랍니다. 자바스크립트에서는 자식 생성자 안에서 `super`를 반드시 호출해야 합니다. `message` 프로퍼티는 부모 생성자에서 설정됩니다.   
   
부모 생성자에선 `message`뿐만 아니라 `name` 프로퍼티도 설정(`"Error"`)하기 때문에, `(2)`에서 원하는 값으로 재설정해주었습니다.   
   
이제 `readUser(json)`안에서 `ValidationError`를 사용해 봅시다.   

```
class ValidationErorr extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

// 사용법
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new ValidationError("No field: age");
  }

  if(!user.name) {
    throw new ValidationError("No field: name");
  }

  return user;
}

// try..catch와 readuser를 함께 사용한 예시

try {
  let user = readUser( '{ "age" : 25 }' );
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Invalid data: " + err.message);  // Invalid data: No field: name
  } else if (err instanceof SyntaxError) {  // (*)
    alert("JSON Syntax Error: " + err.message);
  } else {
    throw err;  // 알려지지 않은 에러는 재던지기 합니다 (**)
  }
}
```

이제 `try..catch` 블록에서 커스텀 에러 `ValidationError`와 `JSON.parse`에서 발생하는 `SyntaxError` 둘 다를 처리할 수 있게 되었습니다.   
   
이 과정에서 `instanceof`로 에러 유형을 확인(`(*)`) 하였습니다.   
   
에러 유형 확인은 `instanceof`말고 다음과 같이 `err.name`을 사용해도 가능합니다.   

```
// ...
// (err instanceof SyntaxError) 대신 사용 가능
} else if (err.name == "SyntaxError") { // (*)
// ...
```

그런데 에러 유형 확인은 `err.name`보다는 `instanceof`를 사용하는게 훨씬 좋습니다. 나중에 `ValidationError`를 확장하여 `PropertyRequiredError`같은 새로운 확장 에러를 만들게 될 텐데, `instanceof`는 새로운 상속 클래스에서도 동작하기 때문입니다.   
   
`catch`에 알려지지 않은 에러가 있을 때 이 에러는 재던지기 된다는 점(`(**)`) 또한 주목해서 봐주시기 바랍니다. `catch`블록에선 유효성 검사와 문법 오류만 처리하고, 다른 종류의 에러는 밖으로 던져야 합니다.   
