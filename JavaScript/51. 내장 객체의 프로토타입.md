# 내장 객체의 프로토타입

`prototype`프로퍼티는 자바스크립트 내부에서도 광범위하게 사용됩니다. 모든 내장 생성자 함수에서 `prototype`프로퍼티를 사용합니다.   
   
이번 챕터에선 내장 객체의 프로토타입에 대해 자세히 살펴본 후, 어떻게 내장 객체의 프로토타입 프로퍼티를 응용할 수 있는지 알아보겠습니다.



## Object.prototype

빈 객체가 있다고 가정해봅시다.
```
let obj = {};
alert( obj );  // "[object Object]" ?
```
`"[object Object]"`문자열을 생성하는 코드는 어디에 있을까요? `toString`메서드에서 이 문자열을 생성한다는 것을 앞서 배워서 알고 있지만 도대체 코드는 어디에 있는 걸까요? `obj`는 비어 있는데 말이죠.   
   
`obj = new Object()`를 줄이면 `obj = {}`가 됩니다. 여기서 `Object`는 내장 객체 생성자 함수인데, 이 생성자 함수의 `prototype`은 `toString`을 비록한 다양한 메서드가 구현되어있는 거대한 객체를 참조합니다.   
   
`new Object()`를 호출하거나 리터럴 문법 `{...}`을 사용해 객체를 만들 때, 새롭게 생성된 객체의 `[[Prototype]]`은 바로 앞 챕터에서 언급한 규칙에 따라 `Object.prototype`을 참조합니다.   
   
따라서 `obj.toString()`을 호출하면 `Object.prototype`에서 해당 메서드를 가져오게 됩니다.
```
let obj = {};

alert(obj.__proto__ === Object.prototype);  // true

alert(obj.toString === obj.__proto__.toString);  // true
alert(obj.toString === Object.prototype.toString);  // true
```
그런데 이때 `Object.prototype` 위쪽엔 `[[Prototype]]`체인이 없다는 점을 주의하셔야 합니다.
```
alert(Object.prototype.__proto__);  // null
```



## 다양한 내장 객체의 프로토타입

`Array`, `Date`, `Function`을 비롯한 내장 객체들 역시 프로토타입에 메서드를 저장해 놓습니다.   
   
배열 `[1, 2, 3]`을 만들면 `new Array()`의 디폴트 생성자가 내부에서 동작하여 `Array.prototype`이 배열 `[1, 2, 3]`의 프로토타입이 되고 개발자는 `Array.prototype`을 통해 배열 메서드를 사용할 수 있습니다. 이런 내부 동작은 메모리 호율을 높여주는 장점을 가져다줍니다.   
   
명세서에선 모든 내장 프로토타입의 상속 트리 꼭대기엔 `Object.prototype`이 있어야 한다고 규정합니다. 이런 명세 때문에 몇몇 사람들은 "모든 것은 객체를 상속받는다." 라는 말을 하기도 합니다.   
   
이번엔 코드로 각 내장 객체의 프로토타입을 직접 확인해 봅시다.
```
let arr = [1, 2, 3];

// arr은 Array.prototype을 상속받았나요?
alert( arr.__proto__ === Array.prototype );  // true

// arr은 Object.prototype을 상속받았나요?
alert( arr.__proto__.__proto__ === Object.prototype );  // true

// 체인 맨 위엔 null이 있습니다.
alert( arr.__proto__.__proto__.__proto__); // null
```
체인 상의 프로토타입엔 중복 메서드가 있을 수 있습니다. `Array.prototype`엔 요소 사이에 쉼표를 넣어 요소 전체를 합친 문자열을 반환하는 자체 메서드 `toString`이 있습니다.
```
let arr = [1, 2, 3]
alert(arr);  // 1,2,3  <-- Array.prototype.toString의 결과
```
그런데 `Object.prototype`에도 메서드 `toString`이 있습니다. 이렇게 중복 메서드가 있을 때는 체인 상에서 가까운 곳에 있는 메서드가 사용됩니다. `Array.prototype`이 체인 상에서 더 가깝기 때문에 예시에선 `Array.prototype`의 `toString`이 사용되었습니다.   
   
Chrome 개발자 콘솔과 같은 도구를 사용하면 상속관계를 확인할 수 있습니다. `console.dir`를 사용하면 내장 객체의 상속 관계를 확인하는 데 도움이 됩니다.   
   
배열이 아닌 다른 내장 객체들 또한 같은 방법으로 동작합니다. 함수도 마찬가지입니다. 함수는 내장 객체 `Function`의 생성자를 사용해 만들어지는데, `call`, `apply`를 비롯한 함수에서 사용할 수 있는 메서드는 `Function.prototype`에서 받아옵니다. 참고로 함수에도 `toString`이 구현되어있습니다.   
```
function f() {}

alert(f.__proto__ == Function.prototype);  // true
alert(f.__proto__.__proto__ == Object.prototype);  // true, 객체에서 상속받음
```
