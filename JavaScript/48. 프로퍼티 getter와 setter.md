# 프로퍼티 getter와 setter

객체의 프로퍼티는 두 종류로 나뉩니다.   
   
첫 번째 종류는 데이터 프로퍼티 입니다. 지금까지 사용한 모든 프로퍼티는 데이터 프로퍼티입니다. 데이터 프로퍼티 조작 방법에 대해선 모두 알고 계실 것이라 생각합니다.   
   
두 번째는 접근자 프로퍼티라 불리는 새로운 종류의 프로퍼티입니다. 접근자 프로퍼티의 본질은 함수인데, 이 함수는 값은 획득(get)하고 설정(set)하는 역할을 담당합니다. 그런데 외부 코드에서 함수가 아닌 일반적인 프로퍼티처럼 보입니다.



## getter와  setter

접근자 프로퍼티는 'getter(획득자)'와 'setter(설정자)'메서드로 표현됩니다. 객체 리터럴 안에서 getter와 setter 메서드는 `get`과 `set`으로 나타낼 수 있습니다.   
```
let obj = {
  get propName() {
    // getter, obj.propName을 실행할 때 실행되는 코드
  },

  set.propName(value) {
    // setter, obj.propName = value를 실행할 때 실행되는 코드
  }
};
```
getter 메서드는 `obj.propName`을 사용해 프로퍼티를 읽으려고 할 때 실행되고, setter 메서드느 `obj.propName = value`으로 프로퍼티에 값을 할당하려 할 때 실행됩니다.   
   
프로퍼티 `name`과 `surname`이 있는 객체 `user`를 만들어봅시다.   
```
let user = {
  name: "John",
  surname: "Smith"
};
```
이 객체에 `fullName`이라는 프로퍼티를 추가해 `fullName`이 `'John Smith'`가 되도록 해봅시다. 기존 값을 복사-붙여넣기 하지 않고 `fullName`이 `'John Smith'`가 되도록 하려면 접근자 프로퍼티를 구현하면 됩니다.   
```
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

alert(user.fullName);  // John Smith
```
바깥 코드에선 접근자 프로퍼티를 일반 프로퍼티처럼 사용할 수 있습니다. 접근자 프로퍼티는 이런 아이디어에서 출발했습니다. 접근자 프로퍼티를 사용하면 함수처럼 호출하지 않고, 일반 프로퍼티에서 값에 접근하는 것처럼 평벙하게 `user.fullName`을 사용해 프로퍼리 값을 얻을 수 있습니다. 나머지 작업은 getter메서드가 뒷단에서 처리해줍니다.   
   
한편, 위 예시의 `fullName`은 getter메서드만 가지고 있기 때문에 `user.fullName=`을 사용해 값을 할당하려고 하면 에러가 발생합니다.   
   
`user.fullName`에 setter 메서드를 추가해 에러가 발생하지 않도록 고쳐봅시다.
```
let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

// 주어진 값을 사용해 set fullName이 실행됩니다.
user.fullName = "Alice Cooper";

alert(user.name);  // Alice
alert(user.surname);  // Cooper
```
이렇게 getter와 setter 메서드를 구현하면 `fullName`이라는 '가상'의 프로퍼티가 생깁니다. 가상의 프로퍼티는 읽고 쓸 순 있지만 실제로는 존재하지 않습니다.



## 접근자 프로퍼티 설명자

데이터 프로퍼티의 설명자와 접근자 프로퍼티의 설명자는 다릅니다.   
   
접근자 프로퍼티엔 설명자 `value`와  `writable`가 없는 대신에 `get`과 `set`이라는 함수가 있습니다.   
   
따라서 접근자 프로퍼티는 다음과 같은 설명자를 갖습니다.   

- `get` - 인수가 없는 함수로, 프로퍼티를 읽을 때 동작함
- `set` - 인수가 하나인 함수로, 프로퍼티에 값을 쓸 때 호출됨
- `enumerable` - 데이터 프로퍼티와 동일함
- `configurable` - 데이터 프로퍼티와 동일함

아래와 같이 `defineProperty`에 설명자 `get`과 `set`을 전달하면 `fullName`을 위한 접근자를 만들 수 있습니다.   
```
let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    retrun `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName); // John Smith
for (let key in user) alert(key);  // name, surname
```
프로퍼티는 접근자 프로퍼티(`get/set` 메서드를 가짐)나 데이터 프로퍼티(`value`를 가짐)중 한 종류에만 속하고 둘 다에 속할 수 없다는 점을 유의하시기 바랍니다.   
   
한 프로퍼티에 `get`과 `value`를 동시에 설정하면 에러가 발생합니다.
```
// Error: Invalid property descriptor.
Object.defineProperty( {}, 'prop', {
  get() {
    return 1
  },

  value: 2
});
```



## getter와  setter 똑똑하게 활용하기

getter와 setter를 '실제'프로퍼티 값을 감싸는 래퍼(wrapper)처럼 사용하면, 프로퍼티 값을 원하는 대로 통제할 수 있습니다.   
   
아래 예시에선 `name`을 위한 setter를 만들어 `user`의 이름이 너무 짧아지는 걸 방지하고 있습니다. 실제 값은 별도의 프로퍼티 `_name`에 저장됩니다.   

```
let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if(value.length < 4) {
      alert("입력하신 값이 너무 짧습니다. 네 글자 이상으로 구성된 이름을 입력하세요.);
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";
alert(user.name);  // Pete

user.name = "";  // 너무 짧은 이름을 할당하려 함
```
`user`의 이름은 `_name`에 저장되고, 프로퍼티에 접근하는 것은 getter와  setter를 통해 이뤄집니다.   
   
기술적으론 외부 코드에서 `user._name`을 사용해 이름에 바로 접근할 수 있습니다. 그러나 밑줄 `"_"`로 시작하는 프로퍼티는 객체 내부에서만 활용하고, 외부에서는 건드리지 않는 것이 관습입니다.
