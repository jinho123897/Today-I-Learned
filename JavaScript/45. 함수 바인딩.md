# 함수 바인딩

`setTimeout`에 메서드를 전달할 때처럼, 객체 메서드를 콜백으로 전달할 때 `this` 정보가 사라지는 문제다 생깁니다.   
   

## 사라진 'this'

앞서 다양한 예제를 통해 `this`정보가 사라지는 문제를 경험해보았습니다. 객체 메서드가 객체 내부가 아닌 다른 곳에 전달되어 호출되면 `this`가 사라집니다.   
   
`setTimeout`을 사용한 아래 예시에서 `this`가 어떻게 사라지는지 살펴봅시다.
```
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`};
  }
};

setTimeout(user.sayHi, 1000);  // Hello, undefined!
```
`this.firstName`이 "John"이 되어야 하는데, 얼럿창엔 `undefiend`가 출력됩니다.   
   
이렇게 된 이유는 `setTimeout`에 객체에서 분리된 함수인 `user.sayHi`가 전달되기 때문입니다. 위 예시의 마지막 줄은 다음 코드와 같습니다.
```
let f = user.sayHi;
setTimeout(f, 1000);  // user 컨텍스트를 잃어버림
```
브라우저 환경에서 `setTimeout`메서드는 조금 특별한 방식으로 동작합니다. 인수로 전달받은 함수를 호출할 때, `this`에 `window`를 할당합니다.(Node.js 환경에서 `this`가 타이머 객체가 되는데, 여기선 중요하지 않으므로 넘어가겠습니다.) 따라서 위 예시의 `this.firstName`은 `window.firstName`가 되는데, `window`객체엔 `firstName`이 없으므로 `undefined`가 출력됩니다. 다른 유사한 사례에서도 대부분의 `this`는 `undefined`가 됩니다.   
   
객체 메서드를 실제 메서드가 호출 되는 곳(예시에선 `setTimeout`스케줄러)으로 전달하는 것은 아주 흔합니다. 이렇게 메서드를 전달할 때, 컨텍스트도 제대로 유지하려면 어떻게 해야 할까요?   
   
## 방법 1: 래퍼
   
가장 간단한 해결책은 래퍼 함수를 사용하는 것입니다.
```
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi();  // Hello, John!
}, 1000);
```
위 예시가 의도한 대로 동작하는 이유는 외부 렉시컬 환경에서 `user`를 받아서 보통 때처럼 메서드를 호출했기 때문입니다.   
```
setTimeout( () => user.sayHi(), 1000);  // Hello, John!
```
이렇게 코드를 작성하면 간결해져서 보기는 좋지만, 약간의 취약성이 생깁니다.   
   
`setTimeout`이 트리거 되기 전에(1초가 지나기 전에) `user`가 변경되면, 변경된 객체의 메서드를 호출하게 됩니다.
```
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);

// 1초가 지나기 전에 user의 값이 바뀜
user = { sayHi() { alert("또 다른 사용자!"); } };

// setTimeout에 또 다른 사용자!
```
두 번째 방법을 사용하면 이런 일이 발생하지 않습니다.   
   
## 방법 2: bind

모든 함수는 `this`를 수정하게 해주는 내장 메서드 bind를 제공합니다.   
   
기본 문법은 다음과 같습니다.
```
let boundFunc = func.bind(context);
```
`func.bind(context)`는 함수처럼 후출 가능한 '특수 객체'를 반환합니다. 이 객체를 호출하면 `this`가 `context`로 고정된 함수 `func`가 반환됩니다.   
   
따라서 `boundFunc`를 호출하면 `this`가 고정된 `func`를 호출하는 것과 동일한 효과를 봅니다.   
   
아래 `funcUser에는 `this`가 `user`로 고정된 `func`이 할당됩니다.   
```
let user = {
  firstName: "John"
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser();  // John
```
여기서 `func.bind(user)`는 `func`의 `this`를 `user`로 '바인딩한 변형'이라고 생각하지면 됩니다.   
   
인수는 원본 함수 `func`에 그대로 전달됩니다.

