# 객체로서의 함수와 기명 함수 표현식
   
자바스크립트에서 함수는 값으로 취급됩니다. 이에 대해선 이미 배워서 알고 계실 겁니다.   
   
모든 값은 자료형을 가지고 있는데, 그렇다면 함수의 자료형은 무엇일까요?   
   
함수는 객체입니다.   
   
함수는 호출이 가능한 '행동 객체'라고 이해하면 쉽습니다. 우리는 함수를 호출 할 수 있을 뿐만 아니라 객체처럼 함수에 프로퍼티를 추가,제거하거나 참조를 전달할 수도 있습니다.
   


## 'name'프로퍼티
   
함수 객체엔 몇 가지 쓸만한 프로퍼티가 있습니다.   
   
'name'프로퍼티를 사용하면 함수 이름을 가져올 수 있죠.
```
function sayHi() {
  alert("Hi");
}

alert(sayHi.name);  // sayHi
```
함수 객체에 이름을 할당해주는 로직은 아주 똑똑해서 익명 함수라도 자동으로 이름이 할당됩니다.
```
let sayHi = function() {
  alert("Hi");
};

alert(sayHi.name); // sayHi
```
기본값을 사용해 이름을 할당한 경우에도 마찬가지죠.
```
function f(sayHi = function() {}){
  alert(sayHi.name);  // sayHi
}

f();
```
자바스크립트 명세서에서 정의된 이 기능을 'contextual name'이라고 부릅니다. 이름이 없는 함수의 이름을 지정할 땐 컨텍스트에서 이름을 가져오죠.   
   
객체 메서드의 이름도 'name'프로퍼티를 이용해 가져올 수 있습니다.
```
let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name);  // sayHi
alert(user.sayBye.name);  //sayBye
```
그런데 객체 메서드 이름은 함수처럼 자동 할당이 되지 않습니다. 적절한 이름을 추론하는 게 불가능한 상황이 있는데, 이때 name 프로퍼티엔 빈 문자열이 저장됩니다. 아래와 같이 말이죠.
```
// 배열 안에서 함수를 생성함
let arr = [function() {}];

alert( arr[0].name );  // <빈 문자열>
// 엔진이 이름을 설정할 수 없어서 name 프로퍼티의 값이 빈 문자열이 됨
```
실무에서 대부분의 함수는 이름이 있으므로 위와 같은 상황은 잘 발생하지 않습니다.
   


## 'length'프로퍼티
   
내장 프로퍼티 `length`는 함수 매개변수의 개수를 반환합니다. 예시를 살펴봅시다.
```
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length);  // 2
```
위 예시를 통해 나머지 매개변수는 개수에 포함되지 않는다는 사실 또한 확인해 보았습니다.   
   
한편, `length`프로퍼티는 다른 함수 안에서 동작하는 함수의 타입을 검사 할 때도 종종 사용됩니다.   
   
질문에 쓰일 `question`과 질문에 대한 답에 따라 호출할 임의의 수의 `handler`함수를 함께 받는 함수 `ask`를 예시로 이에 대해 알아봅시다.   
   
사용자가 답을 제출하면 `ask`는 핸들러 함수를 호출합니다. 이때 우리는 두 종류의 핸들러 함수를 `ask`에 전달할 수 있습니다.
- 인수가 없는 함수로, 사용자가 OK를 클릭했을 때만 호출됨
- 인수가 있는 함수로, 사용자가 OK를 클릭하든 Cancel을 클릭하든 호출됨

그리고 `handler.length`프로퍼티를 사용하면 상황에 맞는 `handler`를 호출할 수 있습니다.   
   
사용자가 긍정적인 대답을 했을 때 사용할 인수가 없는 핸들러를 하나 만들고, 사용자의 응답 종류와 관계업이 범용적으로 사용할만한 핸들러도 구축해 `ask`내부에서 `handler.length`와 함께 사용하면 되죠.
```
function ask(question, ...handlers) {
  let isYes = confirm(question);

  for (let handler of handlers) {
    if (handler.length == 0) {
      if(isYes) handler();
    } else {
      handler(isYes);
    }
  }
}

// 사용자가 OK를 클릭한 경우, 핸들러 두 개를 모두 호출함
// 사용자가 Cancel을 클릭한 경우, 두 번째 핸들러만 호출함
ask("질문 있으신가요?", () => alert('OK를 선택하셧습니다.'), result => alert(result));
```
인수의 종류에 따라(위 예시에선 인수의 `length`프로퍼티 값에 따라) 인수를 다르게 처리하는 방식을 프로그래밍 언어에선 다형성이라고 부릅니다. 자바스크립트 라이브러리를 뜯어보다 보면 다형성이 곳곳에서 사용되고 있다는 것을 확인할 수 있습니다.
   


## 커스텀 프로퍼티
   
함수에 자체적으로 만든 프로퍼티를 추가할 수도 있습니다.   
   
이런 특징을 이용해 함수 호출 횟수를 `counter` 프로퍼티에 저장해보겠습니다.
```
function sayHi() {
  alert("Hi");

  // 함수를 몇 번 호출했는지 세봅시다.
  sayHi.counter++;
}

sayHi.counter = 0;  // 초깃값

sayHi();  // Hi
sayHi(); // Hi

alert( `호출 횟수 : ${sayHi.counter}회` );  // 호출 횟수 : 2회
```
   
❗프로퍼티는 변수가 아닙니다.   
`sayHi.counter = 0`와 같이 함수에 프로퍼티를 할당해도 함수 내에 지역변수 `counter`가 만들어지지 않습니다. `counter`프로퍼티와 변수 `let counter`는 전혀 관계가 없습니다.   
프로퍼티를 저장하는 것처럼 함수를 객체처럼 다룰 수 있지만, 이는 실행에 아무 영향을 끼치지 않습니다. 변수는 함수 프로퍼티가 아니고 함수 프로퍼티는 변수가 아니기 때문입니다. 둘 사이에는 공통점이 없습니다.   
   
클로저는 함수 프로퍼티로 대체할 수 있습니다. 변수의 유효범위와 클로저 챕터에서 살펴본 바 있는 counter함수를 함수 프로퍼티를 사용해 바꿔보도록 하겠습니다.   
```
function makeCounter() {
  // let count = 0 대신 아래 메서드를 사용함
  function counter() {
    return counter.count++;
  }

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() );  // 0
alert( counter() );  // 1
```
이제 `count`는 외부 렉시컬 환경이 아닌 함수 프로퍼티에 바로 저장됩니다.   
   
그런데 과연 이렇게 함수 프로퍼티에 정보를 저장하는 게 클로저를 사용하는 것보다 나은 방법일까요?   
   
두 방법의 차이점은 `count`값이 외부 변수에 저장되어있는 경우 드러납니다. 클로저를 사용한 경우엔 외부코드에서 `count`에 접근할 수 없습니다. 오직 중첩함수 내에서만 `count`값을 수정할 수 있습니다. 반면 함수 프로퍼티를 사용해 `count`를 함수에 바인딩시킨 경우엔 다음 예시와 같이 외부에서 값을 수정할 수 있습니다.
```
function makeCounter() {
  function counter() {
    return counter.count++;
  };

  counter.conut = 0;

  return counter;
}

let counter = makeCounter();

counter.count = 10;
alert( counter() );  // 10
```
따라서 구현 방법은 목적에 따라 선택하면 될 것 같습니다.
